Na dzień dzisiejszy z poziomu bazy danych utworzyłem triggery przesuwające:  
- węzeł oraz wszystkie końcówki linii - jeśli edytujemy punkt elastyczności,  
- punkt elastyczności oraz wszystkie końcówki linii - jeśli edytujemy węzeł  
  
W planach:  
- LISTEN - NOTIFY - czyli automatyczne odświeżenie warstwy jeśli ktoś inny naniósł na nią jakieś zmiany (raczej w czerwcu),    
- historia zmian w bazie (**na pewno nie w maju**),  
- jakiekolwiek inne triggery potrzebne np. do usług w adresach.  
  
1. Nie będę tu rozwodził się zbyt mocno nad samymi triggerami (odsyłam do [oficjalnej dokumentacji - podstawowej](https://www.postgresql.org/docs/15/sql-createtrigger.html)
oraz [oficjalnej dokumentacji - zaawansowanej](https://www.postgresql.org/docs/15/triggers.html)). Tak w skrócie chodzi o to, że możemy
utworzyć specjalną funkcję, odpalaną **przed** lub **po** transakcji w bazie danych, która będzie coś nam robiła - na przykład 
(jak w tym wypadku) aktualizowała **inne tabele** niż ta którą sami zmieniliśmy. Taka funkcja składa się z 2 elementów: samej funkcji
oraz przypisania tej funkcji do konkretnej tabeli (z przeróżnymi możliwymi parametrami). Poniżej działające przykłady.  

2. Trigger na warstwie (czyli tabeli) **punkty_elastycznosci_base**:  

- zaczynamy od konfiguracji funkcji:
```
CREATE OR REPLACE FUNCTION punkty_elastycznosci_base_after_update() RETURNS trigger LANGUAGE 'plpgsql' COST 100 VOLATILE NOT LEAKPROOF AS $punkty_elastycznosci_base_after_update$
BEGIN
	IF TG_OP = 'UPDATE' THEN
		-- Sprawdzenie czy zmieniły się koordynaty i gdzie:
		IF NEW.pe09_szerokosc != OLD.pe09_szerokosc OR NEW.pe10_dlugosc != OLD.pe10_dlugosc THEN
			-- Zmiana w węzłach:
			IF OLD.common_namepart IN (SELECT common_namepart FROM wezly_base) THEN
				UPDATE wezly_base SET geom = st_point(NEW.pe10_dlugosc, NEW.pe09_szerokosc, 4326), we08_szerokosc = NEW.pe09_szerokosc, we09_dlugosc = NEW.pe10_dlugosc WHERE common_namepart = OLD.common_namepart;
			END IF;	
			-- Zmiana gps punktu początkowego w liniach:	
			IF OLD.pe01_id_pe IN (SELECT lk02_id_punktu_poczatkowego FROM linie_kablowe_base) THEN
				-- Podmiana punktu początkowego w geometrii:
				UPDATE linie_kablowe_base SET geom = ST_SetPoint( geom, 0, ST_Point(NEW.pe10_dlugosc, NEW.pe09_szerokosc, 4326)), 
				szerokosc_punktu_poczatkowego = NEW.pe09_szerokosc , dlugosc_punktu_poczatkowego = NEW.pe10_dlugosc WHERE lk02_id_punktu_poczatkowego = OLD.pe01_id_pe;
			END IF;	
			-- Zmiana gps punktu końcowego w liniach:	
			IF OLD.pe01_id_pe IN (SELECT lk04_id_punktu_koncowego FROM linie_kablowe_base) THEN
				-- Podmiana punktu końcowego w geometrii:			
				UPDATE linie_kablowe_base SET geom = ST_SetPoint( geom, ST_NPoints(geom) - 1, ST_Point(NEW.pe10_dlugosc, NEW.pe09_szerokosc, 4326)), 
				szerokosc_punktu_koncowego = NEW.pe09_szerokosc , dlugosc_punktu_koncowego = NEW.pe10_dlugosc WHERE lk04_id_punktu_koncowego = OLD.pe01_id_pe;
			END IF;
		END IF;	
		-- Koordynaty się nie zmieniły. Pozostaje sprawdzić common_namepart i pe01_id_pe:
		IF NEW.common_namepart != OLD.common_namepart THEN
			IF OLD.common_namepart IN (SELECT common_namepart FROM wezly_base) THEN
				UPDATE wezly_base SET common_namepart = NEW.common_namepart, we01_id_wezla = CONCAT('WW_', NEW.common_namepart) WHERE common_namepart = OLD.common_namepart;
			END IF;
		END IF;	
		IF NEW.pe01_id_pe != OLD.pe01_id_pe THEN
			IF OLD.pe01_id_pe IN (SELECT lk02_id_punktu_poczatkowego FROM linie_kablowe_base) THEN
				UPDATE linie_kablowe_base SET lk02_id_punktu_poczatkowego = NEW.pe01_id_pe WHERE lk02_id_punktu_poczatkowego = OLD.pe01_id_pe;
			END IF;
			IF OLD.pe01_id_pe IN (SELECT lk04_id_punktu_koncowego FROM linie_kablowe_base) THEN
				UPDATE linie_kablowe_base SET lk04_id_punktu_koncowego = NEW.pe01_id_pe WHERE lk04_id_punktu_koncowego = OLD.pe01_id_pe;
			END IF;
		END IF;
	RETURN NEW;
	END IF;		
END;
$punkty_elastycznosci_base_after_update$;
```
zakładam (mam nadzieję :]), że opisy w treści funkcji wystarczą.  
- teraz przyporządkowanie ww. do tabeli:  
```
CREATE TRIGGER punkty_elastycznosci_base_after_update_trigger
    AFTER UPDATE OF common_namepart, pe01_id_pe, pe09_szerokosc, pe10_dlugosc
    ON public.punkty_elastycznosci_base
    FOR EACH ROW
    WHEN (NEW.common_namepart::text <> OLD.common_namepart::text OR NEW.pe01_id_pe::text <> OLD.pe01_id_pe::text OR NEW.pe09_szerokosc <> OLD.pe09_szerokosc OR NEW.pe10_dlugosc <> OLD.pe10_dlugosc)
    EXECUTE FUNCTION public.punkty_elastycznosci_base_after_update();
```
jak łatwo zgadnąć - trigger zostanie odpalony jeśli zauważy UPDATE którejś z 4 kolumn tabeli (AFTER UPDATE OF...) i do tego tylko wtedy,
jeśli wartości w ww. będą zmienione.  

3. Trigger na warstwie (czyli tabeli) **wezly_base**:  

- funkcja:  
```
CREATE OR REPLACE FUNCTION wezly_base_after_update() RETURNS trigger LANGUAGE 'plpgsql' COST 100 VOLATILE NOT LEAKPROOF AS $wezly_base_after_update$
BEGIN
	IF TG_OP = 'UPDATE' THEN
		-- Sprawdzenie czy zmieniły się koordynaty i gdzie:
		IF NEW.we08_szerokosc != OLD.we08_szerokosc OR NEW.we09_dlugosc != OLD.we09_dlugosc THEN
			-- Zmiana w punktach elastyczności:
			IF OLD.common_namepart IN (SELECT common_namepart FROM punkty_elastycznosci_base) THEN
				UPDATE punkty_elastycznosci_base SET geom = st_point(NEW.we09_dlugosc, NEW.we08_szerokosc, 4326), pe09_szerokosc = NEW.we08_szerokosc, pe10_dlugosc = NEW.we09_dlugosc WHERE common_namepart = OLD.common_namepart;
			END IF;	
			-- Zmiana gps punktu początkowego w liniach:	
			IF CONCAT('PE_', OLD.common_namepart) IN (SELECT lk02_id_punktu_poczatkowego FROM linie_kablowe_base) THEN
				-- Podmiana punktu początkowego w geometrii:
				UPDATE linie_kablowe_base SET geom = ST_SetPoint( geom, 0, ST_Point(NEW.we09_dlugosc, NEW.we08_szerokosc, 4326)), 
				szerokosc_punktu_poczatkowego = NEW.we08_szerokosc , dlugosc_punktu_poczatkowego = NEW.we09_dlugosc WHERE lk02_id_punktu_poczatkowego = CONCAT('PE_', OLD.common_namepart);
			END IF;	
			-- Zmiana gps punktu końcowego w liniach:	
			IF CONCAT('PE_', OLD.common_namepart) IN (SELECT lk04_id_punktu_koncowego FROM linie_kablowe_base) THEN
				-- Podmiana punktu końcowego w geometrii:			
				UPDATE linie_kablowe_base SET geom = ST_SetPoint( geom, ST_NPoints(geom) - 1, ST_Point(NEW.we09_dlugosc, NEW.we08_szerokosc, 4326)), 
				szerokosc_punktu_koncowego = NEW.we08_szerokosc , dlugosc_punktu_koncowego = NEW.we09_dlugosc WHERE lk04_id_punktu_koncowego = CONCAT('PE_', OLD.common_namepart);
			END IF;
		END IF;	
		-- Koordynaty się nie zmieniły. Pozostaje sprawdzić common_namepart i we01_id_wezla:
		IF NEW.common_namepart != OLD.common_namepart THEN
			IF OLD.common_namepart IN (SELECT common_namepart FROM punkty_elastycznosci_base) THEN
				UPDATE punkty_elastycznosci_base SET common_namepart = NEW.common_namepart, pe01_id_pe = CONCAT('PE_', NEW.common_namepart), pe03_id_wezla = NEW.we01_id_wezla WHERE common_namepart = OLD.common_namepart;
			END IF;
		END IF;	
	RETURN NEW;
	END IF;		
END;
$wezly_base_after_update$;
```

- i przyporządkowanie:  

```
CREATE TRIGGER wezly_base_after_update_trigger
    AFTER UPDATE OF common_namepart, we01_id_wezla, we08_szerokosc, we09_dlugosc
    ON public.wezly_base
    FOR EACH ROW
    WHEN (NEW.common_namepart::text <>  OLD.common_namepart::text OR NEW.we01_id_wezla::text <> OLD.we01_id_wezla::text OR NEW.we08_szerokosc <> OLD.we08_szerokosc OR NEW.we09_dlugosc <> OLD.we09_dlugosc)
    EXECUTE FUNCTION public.wezly_base_after_update();
```

4. Jak znajdę chwilkę to pewnie dopiszę coś jeszcze.